<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Systems on Weizlogy</title>
    <link>http://www.weizlogy.gq/system/</link>
    <description>Recent content in Systems on Weizlogy</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© 2010 weizlogy.</copyright>
    <lastBuildDate>Mon, 27 Mar 2017 03:37:14 +0900</lastBuildDate>
    
	<atom:link href="http://www.weizlogy.gq/system/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[system development] strutsでJSPで動的に一覧表示した複数のForm値をServletで簡単に渡す</title>
      <link>http://www.weizlogy.gq/system/dev/struts-form-to-servlet-easily/</link>
      <pubDate>Mon, 27 Mar 2017 03:37:14 +0900</pubDate>
      
      <guid>http://www.weizlogy.gq/system/dev/struts-form-to-servlet-easily/</guid>
      <description>strutsのActionFormには、「map-backed properties」「list-backed properties」という機能があります。
ActionFormにMapやListのフィールドと適切なアクセサーメソッドを用意することで、JSP-Servlet間のデータ送受信が動的に行われる仕組みです。
Formのフィールドをいくつも用意しなくていいところが、とても便利です。
基本的な使い方は、下記公式リンクが分かりやすくなっています。
http://struts.apache.org/1.x/userGuide/building_controller.html#map_action_form_classes
今回の趣旨は、「map-backed properties」「list-backed properties」を併用することです。 検索結果等JSPで動的に一覧表示した複数のForm値を、簡単にActionで受け取ることができます。
struts1.3.10
java 1.6.0_18
以下のようなFormクラスを用意します。
import org.apache.commons.beanutils.LazyDynaList; import org.apache.commons.beanutils.LazyDynaMap; public HogeForm extends ActionForm { private LazyDynaList values = new LazyDynaList(LazyDynaMap.class); public String getValue(int index) { return values.get(index); } public void setValue(int index, Object value) { return values.set(index, value); } public List&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt; getValues() { // LazyDynaList, LazyDynaMapのままでは扱いにくいため、より一般的な型（List, Map）に変換します。 List&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt; convertValues = new ArrayList&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt;(); for (Object item : values) { convertValues.</description>
    </item>
    
    <item>
      <title>[system development] Windows XP上でIcmp6SendEcho2()呼び出し時、異常終了しないために</title>
      <link>http://www.weizlogy.gq/system/dev/avoid-error-icmp6sendecho2/</link>
      <pubDate>Sun, 26 Mar 2017 15:42:59 +0900</pubDate>
      
      <guid>http://www.weizlogy.gq/system/dev/avoid-error-icmp6sendecho2/</guid>
      <description>Windows APIのIcmp6SendEcho2()をWindows XPで呼び出すときは以下の点に注意が必要です。
Syntax from msdn.
DWORD Icmp6SendEcho2( __in HANDLE IcmpHandle, __in_opt HANDLE Event, __in_opt PIO_APC_ROUTINE ApcRoutine, __in_opt PVOID ApcContext, __in struct sockaddr_in6 *SourceAddress, __in struct sockaddr_in6 *DestinationAddress, __in LPVOID RequestData, __in WORD RequestSize, __in_opt PIP_OPTION_INFORMATION RequestOptions, __out LPVOID ReplyBuffer, __in DWORD ReplySize, __in DWORD Timeout );   第9引数 PIP_OPTION_INFORMATION は必須です。Vista 以降のOSで動かす場合は任意です。（NULLでもよい） 第10引数 ReplyBuffer は80byte以上の領域がないとWin32エラーコード122（システム コールに渡されるデータ領域が小さすぎます）が発生します。  IcmpSendEcho()とは設定値が微妙に異なりますね。</description>
    </item>
    
    <item>
      <title>[system development] cannot find source for binding with reference について</title>
      <link>http://www.weizlogy.gq/system/dev/cannot-find-source-for-binding-with-reference/</link>
      <pubDate>Sun, 26 Mar 2017 15:42:56 +0900</pubDate>
      
      <guid>http://www.weizlogy.gq/system/dev/cannot-find-source-for-binding-with-reference/</guid>
      <description>掲題の件について、検索キーワードにあがりましたので、簡単にまとめました。
正式には、以下のErrorが発生しました。
System.Windows.Data Error: 4 : Cannot find source for binding with reference &amp;lsquo;RelativeSource FindAncestor, AncestorType=&amp;lsquo;System.Windows.Controls.ItemsControl&amp;rsquo;, AncestorLevel=&amp;lsquo;1&amp;rdquo;. BindingExpression:Path=HorizontalContentAlignment; DataItem=null; target element is &amp;lsquo;ListBoxItem&amp;rsquo; (Name=&amp;ldquo;); target property is &amp;lsquo;HorizontalContentAlignment&amp;rsquo; (type &amp;lsquo;HorizontalAlignment&amp;rsquo;)
System.Windows.Data Error: 4 : Cannot find source for binding with reference &amp;lsquo;RelativeSource FindAncestor, AncestorType=&amp;lsquo;System.Windows.Controls.ItemsControl&amp;rsquo;, AncestorLevel=&amp;lsquo;1&amp;rdquo;. BindingExpression:Path=VerticalContentAlignment; DataItem=null; target element is &amp;lsquo;ListBoxItem&amp;rsquo; (Name=&amp;ldquo;); target property is &amp;lsquo;VerticalContentAlignment&amp;rsquo; (type &amp;lsquo;VerticalAlignment&amp;rsquo;)
xamlのStyle定義のSetterプロパティでAlignmentを定義していると出るみたいです。 定義を外すとErrorは出ません。 みたいです。というのは、何故なのか理由が分からないためです。
以下、実際のコードの抜粋です。
&amp;lt;Style TargetType=&amp;quot;{x:Type ListBoxItem}&amp;quot;&amp;gt; &amp;lt;Setter Property=&amp;quot;HorizontalContentAlignment&amp;quot; Value=&amp;quot;{Binding Path=HorizontalContentAlignment, RelativeSource={RelativeSource AncestorType={x:Type ItemsControl}}}&amp;quot;/&amp;gt; &amp;lt;Setter Property=&amp;quot;VerticalContentAlignment&amp;quot; Value=&amp;quot;{Binding Path=VerticalContentAlignment, RelativeSource={RelativeSource AncestorType={x:Type ItemsControl}}}&amp;quot;/&amp;gt;  </description>
    </item>
    
    <item>
      <title>[system development] TSLで定義される全CipherSuiteの一覧</title>
      <link>http://www.weizlogy.gq/system/dev/cipher-suites/</link>
      <pubDate>Sun, 26 Mar 2017 15:42:52 +0900</pubDate>
      
      <guid>http://www.weizlogy.gq/system/dev/cipher-suites/</guid>
      <description>Cipher Suiteの説明はさて置き、一覧を見るために以下のコマンドを使用する例が多々見受けられます。
$ openssl ciphers -v  これはopensslが対応するCipherSuiteの一覧であり、実際に存在するCipherSuiteの一覧とは異なります。
実際に存在するCipherSuiteの一覧は、RFC5426によるとIANA管理とのことで、下記URLがマスターです。
http://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-4</description>
    </item>
    
    <item>
      <title>[system development] Codeanywhereでbazelを使う</title>
      <link>http://www.weizlogy.gq/system/dev/codeanywhere-with-bezel/</link>
      <pubDate>Sun, 26 Mar 2017 15:42:48 +0900</pubDate>
      
      <guid>http://www.weizlogy.gq/system/dev/codeanywhere-with-bezel/</guid>
      <description>CodeanywhereはクラウドIDEで、sudoが許可されたターミナルを使うことができます。 Google+アカウント連携ですぐに使えます。
bazelは、mavenやGradleのようなビルドツールで、様々な言語のビルドが可能です。
Codeanyhwereにbazelをインストール bazelはjdk1.8以降（jdk1.7はサポートされているが非推奨）が必須ですが、Codeanywhereはjdk1.7の環境です。 今回はjdk1.7のままでインストールします。
cabox@box-codeanywhere:~/workspace$ java -version java version &amp;quot;1.7.0_95&amp;quot; OpenJDK Runtime Environment (IcedTea 2.6.4) (7u95-2.6.4-0ubuntu0.14.04.1) OpenJDK 64-Bit Server VM (build 24.95-b01, mixed mode)  Installig Bazelを参考に、以下のコマンドを打ちます。
$ echo &amp;quot;deb [arch=amd64] http://storage.googleapis.com/bazel-apt testing jdk1.7&amp;quot; | sudo tee /etc/apt/sources.list.d/bazel.list $ curl https://storage.googleapis.com/bazel-apt/doc/apt-key.pub.gpg | sudo apt-key add - sudo apt-get update &amp;amp;&amp;amp; sudo apt-get install bazel  bazelでjavaをビルド 最低限の必要なファイルを作成します。
cabox@box-codeanywhere:~/workspace$ mkdir -p hello/src/main/java/gq/weizlogy cabox@box-codeanywhere:~/workspace$ touch hello/src/main/java/gq/weizlogy/Main.java cabox@box-codeanywhere:~/workspace$ touch hello/WORKSPACE cabox@box-codeanywhere:~/workspace$ touch hello/BUILD  hello/src/main/java/gq/weizlogy/Main.</description>
    </item>
    
    <item>
      <title>[system development] Webアプリケーションでサーバー上の画像ファイルをIMGタグに動的出力する</title>
      <link>http://www.weizlogy.gq/system/dev/dynamic-server-img-on-webapp/</link>
      <pubDate>Sun, 26 Mar 2017 15:42:44 +0900</pubDate>
      
      <guid>http://www.weizlogy.gq/system/dev/dynamic-server-img-on-webapp/</guid>
      <description>img タグにサーブレットの URL を埋め込んで、画面描画時に呼び出します。 呼び出した先では画像をバイナリ形式で読み込んで画面に出力します。
データベースに Blob 型で保存した画像の読み込みも、ロジックは同じです。
JSPでは&amp;hellip;
&amp;lt;img src=&amp;quot;xxx.do&amp;quot; /&amp;gt;  サーバーサイドでは&amp;hellip;
/** xxx.do から呼び出される Servlet */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // ファイルパスはどこからか入手する String file = &amp;quot;\\server\image\sample.jpg&amp;quot;; if (file == null || &amp;quot;&amp;quot;.equals(file)) { return; } try { // 画像を読み込む byte[] image = Files.readAllBytes(Paths.get(file)); // レスポンスヘッダーを設定する response.setContentType(&amp;quot;image/&amp;quot; + file.substring(file.lastIndexOf(&amp;quot;.&amp;quot;))); response.setContentLength(image.length); // servlet specification 3.1 によると OutputStream は // Servlet 終了時にクローズされる // 従って、ここではクローズしない // むしろ、ここでクローズすると二重解放になる可能性があるのでは？ response.</description>
    </item>
    
    <item>
      <title>[system development] JQueryUIのAutoCompleteを特定操作で強制選択する</title>
      <link>http://www.weizlogy.gq/system/dev/force-jquery-autocomplete/</link>
      <pubDate>Sun, 26 Mar 2017 15:42:40 +0900</pubDate>
      
      <guid>http://www.weizlogy.gq/system/dev/force-jquery-autocomplete/</guid>
      <description>本来は blur 時に強制選択したかったのですが、候補確定時に AutoComplete の対象にフォーカスが当たる挙動を回避できなかったため、エンターキーで代用です。
var obj = $(&amp;#39;#autocomplete&amp;#39;); obj.on(&amp;#39;keydown&amp;#39;, function(e) { // エンターキー以外を無視する if (e.which !== 13) { return; } // search メソッドの結果で候補が存在する場合、 // autocompleteopen イベントが発行される // 候補が 0 件の場合は動作しない obj.on(&amp;#39;autocompleteopen&amp;#39;, function() { // 下矢印キーダウンイベントを作成し、候補の先頭を選択状態にする var keyDownEvent = $.Event(&amp;#39;keydown&amp;#39;); keyDownEvent.keyCode = $.ui.keyCode.DOWN; obj.trigger(keyDownEvent); // エンターキーダウンを作成し、選択状態の候補で確定する // →候補確定時のイベントが発火する keyDownEvent.keyCode = $.ui.keyCode.ENTER; obj.trigger(keyDownEvent); // 通常動作時は不要なイベントなので終了時に破棄しておく obj.off(&amp;#39;autocompleteopen&amp;#39;); }); // 現在の入力値で検索する obj.autocomplete(&amp;#39;search&amp;#39;); });  </description>
    </item>
    
    <item>
      <title>[system development] Monodevelopで埋め込みリソースを使う</title>
      <link>http://www.weizlogy.gq/system/dev/monodevelop-embed-resource/</link>
      <pubDate>Sun, 26 Mar 2017 15:42:36 +0900</pubDate>
      
      <guid>http://www.weizlogy.gq/system/dev/monodevelop-embed-resource/</guid>
      <description>ソリューションエクスプローラーで対象のファイルを右クリックします。
「ビルドアクション &amp;gt; EmbeddedResource」を選択します。以上です。
プログラムからのアクセスで必要なリソースIDは、デフォルトネームスペース＋ファイル名となります。 リソースIDはプロパティビューで変更可能です。
使い方は以下の通りです。
using (var stream = new System.IO.StreamReader(System.Reflection.Assembly.GetExecutingAssembly().GetManifestResourceStream(&amp;quot;[ResourceID]&amp;quot;), true)) { ... }  </description>
    </item>
    
    <item>
      <title>[system development] ubuntu16.04でMonoDevelopを使った開発環境</title>
      <link>http://www.weizlogy.gq/system/dev/monodevelop-with-ubuntu/</link>
      <pubDate>Sun, 26 Mar 2017 15:42:33 +0900</pubDate>
      
      <guid>http://www.weizlogy.gq/system/dev/monodevelop-with-ubuntu/</guid>
      <description>LinuxでC#を使うための環境(mono)とIDE(MonoDevelop)をインストールします。
まずはmonoをインストールします。
$ sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 3FA7E0328081BFF6A14DA29AA6A19B38D3D831EF $ echo &amp;quot;deb http://download.mono-project.com/repo/debian wheezy main&amp;quot; | sudo tee /etc/apt/sources.list.d/mono-xamarin.list $ sudo apt-get update $ sudo apt-get install mono-complete  続いてMonoDevelopをインストールします。
$ sudo apt-get install monodevelop  monodevelopコマンドでIDEを起動します。</description>
    </item>
    
    <item>
      <title>[system development] Codeaywhere&#43;Java&#43;bazelでOpenWeatherMapのAPIを使用し現在の気象情報を取得する</title>
      <link>http://www.weizlogy.gq/system/dev/openweathermap-with-java-bazel/</link>
      <pubDate>Sun, 26 Mar 2017 15:42:27 +0900</pubDate>
      
      <guid>http://www.weizlogy.gq/system/dev/openweathermap-with-java-bazel/</guid>
      <description>OpenWeatherMapの使い方 OpenWeatherMapは各種気象情報提供サービスです。
サインアップすれば無料で使えるAPIも提供しています。
今回は現在のみなので、Current weather data APIを使用します。 RESTサービスになっており、以下のURLで情報がJSON形式で取得できます。（{city name}は英語で）
http://api.openweathermap.org/data/2.5/weather?q={city name}&amp;amp;APPID={Your API Key}  JSON形式ではJavaで扱いにくいので、&amp;rdquo;mode=xml&amp;rdquo;パラメータでXML形式にします。
http://api.openweathermap.org/data/2.5/weather?q={city name}&amp;amp;mode=xml&amp;amp;APPID={Your API Key}  気象情報は以下のように返却されます。（例は{city name}=Tokyo）
&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt; &amp;lt;current&amp;gt; &amp;lt;city id=&amp;quot;1850147&amp;quot; name=&amp;quot;Tokyo&amp;quot;&amp;gt; &amp;lt;coord lat=&amp;quot;35.69&amp;quot; lon=&amp;quot;139.69&amp;quot;/&amp;gt; &amp;lt;country&amp;gt;JP&amp;lt;/country&amp;gt; &amp;lt;sun set=&amp;quot;2016-08-15T09:30:23&amp;quot; rise=&amp;quot;2016-08-14T20:00:21&amp;quot;/&amp;gt; &amp;lt;/city&amp;gt; &amp;lt;temperature unit=&amp;quot;kelvin&amp;quot; max=&amp;quot;304.82&amp;quot; min=&amp;quot;298.71&amp;quot; value=&amp;quot;301.68&amp;quot;/&amp;gt; &amp;lt;humidity unit=&amp;quot;%&amp;quot; value=&amp;quot;85&amp;quot;/&amp;gt; &amp;lt;pressure unit=&amp;quot;hPa&amp;quot; value=&amp;quot;1001&amp;quot;/&amp;gt; &amp;lt;wind&amp;gt; &amp;lt;speed name=&amp;quot;Gentle Breeze&amp;quot; value=&amp;quot;3.41&amp;quot;/&amp;gt; &amp;lt;gusts/&amp;gt; &amp;lt;direction name=&amp;quot;South&amp;quot; value=&amp;quot;179.504&amp;quot; code=&amp;quot;S&amp;quot;/&amp;gt; &amp;lt;/wind&amp;gt; &amp;lt;clouds name=&amp;quot;clear sky&amp;quot; value=&amp;quot;8&amp;quot;/&amp;gt; &amp;lt;visibility/&amp;gt; &amp;lt;precipitation unit=&amp;quot;3h&amp;quot; value=&amp;quot;0.245&amp;quot; mode=&amp;quot;rain&amp;quot;/&amp;gt; &amp;lt;weather value=&amp;quot;light rain&amp;quot; icon=&amp;quot;10d&amp;quot; number=&amp;quot;500&amp;quot;/&amp;gt; &amp;lt;lastupdate value=&amp;quot;2016-08-15T07:41:15&amp;quot;/&amp;gt; &amp;lt;/current&amp;gt;  JavaでOpenWeatherMapのAPIを呼び出す RESTクライアントは色々ありますが、お手軽なApache Commonsのhttpclientとfluent-hcにします。</description>
    </item>
    
    <item>
      <title>[system development] Spring Framework で ProceedingJoinPoint を引数に持つ AOP Interceptor をテストで呼び出す</title>
      <link>http://www.weizlogy.gq/system/dev/spring-aop-test/</link>
      <pubDate>Sun, 26 Mar 2017 15:42:24 +0900</pubDate>
      
      <guid>http://www.weizlogy.gq/system/dev/spring-aop-test/</guid>
      <description>Interceptor クラスの内容は以下の通りです。
import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; @Aspect public class SomeInterceptor { @Around(&amp;quot;execution(* execute(..))&amp;quot;) public Object around(ProceedingJoinPoint pjp) { System.out.println(String.format(&amp;quot;%s.%s start.&amp;quot;, pjp.getTarget().getClass.getSimpleName(), pjp.getSignature().getName())); Object value = null; try { value = pjp.proceed(); } catch (Throwable e) { e.printStackTrace(); } System.out.println(String.format(&amp;quot;%s.%s ended.&amp;quot;, pjp.getTarget().getClass.getSimpleName(), pjp.getSignature().getName())); return value; } }  Test クラスの内容は以下の通りです。
import static org.junit.Assert.*; import java.util.ArrayList; import org.junit.Test; import org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint; import org.springframework.aop.framework.ReflectiveMethodInvocation; import org.springframework.aop.interceptor.SimpleTraceInterceptor; public class SomeInterceptorTest { /** AOP の対象となるメソッドを持つクラス */ private static class AOPTarget { public String execute() { System.</description>
    </item>
    
    <item>
      <title>[system development] ステップカウンターのあるべき姿を考察する</title>
      <link>http://www.weizlogy.gq/system/dev/step-counter-is/</link>
      <pubDate>Sun, 26 Mar 2017 15:42:20 +0900</pubDate>
      
      <guid>http://www.weizlogy.gq/system/dev/step-counter-is/</guid>
      <description>ステップカウンターとは？ LOCを計測するツールです。LOCはLines Of Codeの略で、プログラムの規模として扱います。
 空行（改行など空白だけの行）やコメント行（コメントと空白だけの行）は除く、2つの命令が書かれた行は2行と数える、括弧だけの行を除くなどの換算をした行数を論理LOC (logical LOC) といい、通常はこちらを使う。
&amp;ndash; https://ja.wikipedia.org/wiki/LOC
 2つの命令が書かれた行は2行と数える、括弧だけの行を除くなどの換算してますか？ 世にあるステップカウンターは、有効行（実行行）、コメント行、空白行の3種を見ていることが多く、高度な換算はされていないようです。
そこで、*本来あるべきステップカウンター*を、以下の考察に基づき鋭意作成中です。
詳細はこちらをご覧ください。
本来あるべきステップカウンターの想定仕様概要  2つの命令が書かれた行は2行と数える。 括弧だけの行を除く。 ディレクティブは考慮が必要。  本来あるべきステップカウンターの想定仕様詳細 2つの命令が書かれた行は2行と数える C言語系統は命令の終端に&amp;rdquo;;&amp;ldquo;が必要な言語使用のため、その終端記号（または文字）を数えれば良い。また、IF文では&amp;rdquo;{&amp;ldquo;、SWITCH-CASE文では&amp;rdquo;{&amp;ldquo;と&amp;rdquo;:&amp;ldquo;に着目することで命令を計測します。
ただし、FOR文は3式で1セットの命令であるため、FOR文中の終端記号は無視しなければいけません。 VBやRubyのような言語、HTMLのようなタグが構成要素の場合は検討中です。
括弧だけの行を除く C言語系統はブロックの終端記号&amp;rdquo;}&amp;ldquo;がありますが、1命令のセットであるため、開始記号&amp;rdquo;{&amp;ldquo;とどちらか一方を測定対象とすべきです。 VBやRubyのような言語の&amp;rdquo;END&amp;rdquo;キーワードも同様です。
ディレクティブは考慮が必要 Javaのimport文、C#のusingディレクティブは、パッケージ名を省略するためだけに存在するもので、記載の有無がプログラムの動作に影響を与えませんので、命令とは位置付け異なります。
C言語系統のプリプロセッサーディレクティブは微妙ですが、動作に影響を与えるものもあるため、命令と考えます。
ただし、&amp;rdquo;#endif&amp;rdquo;、&amp;rdquo;#region&amp;rdquo;、&amp;rdquo;#endregion&amp;rdquo;は非命令とし計測しません。
C言語の#includeは、必須であることを除き、C#のusingディレクティブ同様、非命令とします。
考察は続きます。。。</description>
    </item>
    
    <item>
      <title>[system development] strutsのFormFileからローカルファイルの絶対パスを取得</title>
      <link>http://www.weizlogy.gq/system/dev/struts-formfile-to-local-path/</link>
      <pubDate>Sun, 26 Mar 2017 15:42:11 +0900</pubDate>
      
      <guid>http://www.weizlogy.gq/system/dev/struts-formfile-to-local-path/</guid>
      <description>strutsのFormFileからローカルファイルの絶対パスを取得したいのです。 （取得しても無意味ですが）
eclipseのデバッガで参照すると、確かにprivate変数に絶対パスを持っていますが、アクセスするためのメソッドがありません。
リフレクションでアクセス可能です。
DiskFileItemを使用するために、「commons-fileupload.jar」が必要です。
struts1.3.10
java 1.6.0_18
// formFileの実体は「org.apache.struts.upload.CommonsMultipartRequestHandler.CommonsFormFile」 Field f = formFile.getClass().getDeclaredField(&amp;quot;fileItem&amp;quot;); f.setAccessible(true); // fileItemは「org.apache.commons.fileupload.FileItem」を実装した「org.apache.commons.fileupload.disk.DiskFileItem」 DiskFileItem item = (DiskFileItem) f.get(formFile); System.out.println(item.getName());  </description>
    </item>
    
    <item>
      <title>[system development] BeanUtils.describe()で配列を扱いたい</title>
      <link>http://www.weizlogy.gq/system/dev/use-beanutils-describe-array/</link>
      <pubDate>Sun, 26 Mar 2017 15:42:08 +0900</pubDate>
      
      <guid>http://www.weizlogy.gq/system/dev/use-beanutils-describe-array/</guid>
      <description>題名の通り、BeanUtils.describe()で配列を扱いたいのです。主にStringの配列。
BeanUtils.describe()を使うと、クラスのフィールドをMapに変換してくれますが「文字列として表現可能な形式のもの」に限ります。
Stringの配列については配列の先頭を出力し、残りは切り捨てられます。
※{&amp;ldquo;a&amp;rdquo;, &amp;ldquo;b&amp;rdquo;, &amp;ldquo;c&amp;rdquo;}という配列がある場合、&amp;rdquo;a&amp;rdquo;以外の値が切り捨てられます。
これは、BeanUtilsBeanの仕様となっております。
ただし、「commons beanUtils 1.8.0」以降は以下の回避策があります。
BeanUtilsBean.setInstance(new BeanUtilsBean2()); ArrayConverter converter = new ArrayConverter(String[].class, new StringConverter(), 0); // OnlyFirstToStringがtrueの場合、配列の先頭だけ使用します converter.setOnlyFirstToString(false); ConvertUtils.register(converter, String[].class);  上記処理はインスタンスを共有するため、他に影響がある場合は後処理も必要です。
ConvertUtils.deregister(String[].class); BeanUtilsBean.setInstance(new BeanUtilsBean());  Converterインターフェースを実装したクラスを作成し、ConvertUtilsにregistすると、独自の変換も可能です。</description>
    </item>
    
    <item>
      <title>[system development] XAMLでブロック矢印を描画する</title>
      <link>http://www.weizlogy.gq/system/dev/xaml-with-block-arrow/</link>
      <pubDate>Sun, 26 Mar 2017 15:42:04 +0900</pubDate>
      
      <guid>http://www.weizlogy.gq/system/dev/xaml-with-block-arrow/</guid>
      <description>ブロック矢印完成図 
コード  &amp;lt;Path Stroke=&amp;quot;Black&amp;quot; StrokeThickness=&amp;quot;2&amp;quot; Fill=&amp;quot;Gray&amp;quot; Data=&amp;quot;M 100 100 H 200 V 90 L 230 115 L 200 140 V 130 H 100 V 100 Z&amp;quot; Margin=&amp;quot;-30,-30,0,0&amp;quot; /&amp;gt;  解説 Pathを使って目標の位置付近に描画、Marginで微調整します。
https://msdn.microsoft.com/en-us/library/ms752293%28v=vs.110%29.aspxを読めば分かりますが簡単です。 一筆書きの要領で、矢印の左上から時計回りに線を引いています。
「M 100 100」は「X=100,Y=100に移動」します。
「H 200」は「現在位置からX=200まで描線」します。
「V 90」は「現在位置からY=90まで描線」します。
「L 230 115」は「現在位置からX=230,Y=115まで描線」します。
以下繰り返しの上、 「Z」は「描線の範囲を閉鎖」します。
座標の算出には、描画開始位置、シャフトの幅と高さ、アローヘッドの出代と角度を決めます。 今回は、描画開始位置=100,100、シャフトの幅=100、高さ=30、アローヘッドの出代=10、角度=60にしました。

アローヘッドの頂点座標の算出は、頂点がシャフトの中央にあることと、三平方の定理を使えばきっちり出せます。 つまり、シャフトの幅は偶数が良いです。</description>
    </item>
    
    <item>
      <title>[system] Schritt - 論理ステップカウンター</title>
      <link>http://www.weizlogy.gq/system/item/schritt/</link>
      <pubDate>Sun, 26 Mar 2017 15:42:00 +0900</pubDate>
      
      <guid>http://www.weizlogy.gq/system/item/schritt/</guid>
      <description>overviews. Schrittは論理ステップカウンターです。
従来のステップカウンターは物理行でカウントする方式が主流であるため、書き方により規模に差異が現れます。
Schrittは論理的に命令をカウントすることで、書き方による規模の差異を抑制することを目的に作られました。
SchrittはLinux(ubuntu)のMonoを使用し、C#で実装されているため、.Net Frameworkの恩恵を受けられる環境であれば動作します。
download. Schritt
status. | 言語 | 対応バージョン | 状況説明 | |:&amp;mdash;||:&amp;mdash;||:&amp;mdash;| | C | 0.0.3-α | | | C++ | | 順次対応予定 | | C# | 0.0.1-α | | | Java | 0.0.2-α | | | VB | | 順次対応予定 | | JavaScript | | 順次対応予定 | | HTML | | 順次対応予定 | | CSS | | 順次対応予定 | | Ruby | | 順次対応予定 |</description>
    </item>
    
    <item>
      <title>[system] Tapete - Windows spotlight画像抽出</title>
      <link>http://www.weizlogy.gq/system/item/tapete/</link>
      <pubDate>Sun, 26 Mar 2017 15:41:54 +0900</pubDate>
      
      <guid>http://www.weizlogy.gq/system/item/tapete/</guid>
      <description>overviews. Windows10のロック画面で使われるspotlight画像を厳選し、&amp;lt;ユーザーディレクトリ&amp;gt;\picture\Tapete フォルダにコピーします。
コピーは随時発生し、日次で最新状態にリセットします。
壁紙のスライドショーで使用することを想定し、画像の厳選条件は、4KB以上かつ、 プライマリースクリーンの解像度以上としています。
download. Tapete.zip
install. ダウンロードしたzipを解凍し、任意の場所に配置します。
descriptions. 画面のフォルダパスをクリックすると、該当フォルダをエクスプローラーで開きます。
最小化すると通知アイコン化します。アイコンをクリックすると復元します。
cautions. 自動起動はしないので、必要に応じてスタートアップに登録してください。
コピー先は固定なので、ソフトリンクやジャンクションで任意の場所にコピーさせることもできます。</description>
    </item>
    
  </channel>
</rss>